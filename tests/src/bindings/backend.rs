// This is an experimental feature used to generate Rust bindings from Candid.
// THIS IS A GENERATED FILE. DO NOT EDIT THIS FILE TO AVOID DATA LOSS.
#![allow(dead_code, unused_imports, non_snake_case)]
use candid::{self, CandidType, Decode, Deserialize, Encode, Principal};

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct Person {
    pub id: u32,
    pub occupation: String,
    pub name: String,
    pub email: String,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub enum ResultPerson {
    Ok(Person),
    Err(String),
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct Todo {
    pub id: u32,
    pub done: bool,
    pub text: String,
    pub person_id: u32,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub enum ResultTodo {
    Ok(Todo),
    Err(String),
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub enum ResultVecPerson {
    Ok(Vec<Person>),
    Err(String),
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct QueryPersons {
    pub offset: u32,
    pub limit: u32,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct SelectTodo {
    pub person_id: u32,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub enum ResultVecTodo {
    Ok(Vec<Todo>),
    Err(String),
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct NewPerson {
    pub occupation: String,
    pub name: String,
    pub email: String,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct NewTodo {
    pub done: bool,
    pub text: String,
    pub person_id: u32,
}

#[derive(CandidType, Clone, Debug, Deserialize, PartialEq)]
pub struct UpdateTodo {
    pub id: u32,
    pub done: bool,
    pub text: String,
}

pub struct BackendCanister {
    pub canister_id: Principal,
    pub caller: super::Caller,
}

impl BackendCanister {
    pub fn add_demo_data(&self) -> super::CallBuilder<()> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "add_demo_data",
            args,
        )
    }
    pub fn delete_person(&self, arg0: u32) -> super::CallBuilder<ResultPerson> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "delete_person",
            args,
        )
    }
    pub fn delete_todo(&self, arg0: u32) -> super::CallBuilder<ResultTodo> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "delete_todo",
            args,
        )
    }
    pub fn dummy_update(&self) -> super::CallBuilder<()> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "dummy_update",
            args,
        )
    }
    pub fn get_person(&self, arg0: u32) -> super::CallBuilder<ResultPerson> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "get_person", args)
    }
    pub fn get_persons(&self) -> super::CallBuilder<ResultVecPerson> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "get_persons",
            args,
        )
    }
    pub fn list_persons(&self, arg0: QueryPersons) -> super::CallBuilder<ResultVecPerson> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Query,
            "list_persons",
            args,
        )
    }
    pub fn list_todos(&self, arg0: SelectTodo) -> super::CallBuilder<ResultVecTodo> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Query, "list_todos", args)
    }
    pub fn new_person(&self, arg0: NewPerson) -> super::CallBuilder<ResultPerson> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "new_person",
            args,
        )
    }
    pub fn new_todo(&self, arg0: NewTodo) -> super::CallBuilder<ResultTodo> {
        let args = Encode!(&arg0);
        self.caller
            .call(self.canister_id, super::CallMode::Update, "new_todo", args)
    }
    pub fn reset_base(&self) -> super::CallBuilder<()> {
        let args = Encode!();
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "reset_base",
            args,
        )
    }
    pub fn update_person(&self, arg0: Person) -> super::CallBuilder<ResultPerson> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "update_person",
            args,
        )
    }
    pub fn update_todo(&self, arg0: UpdateTodo) -> super::CallBuilder<ResultTodo> {
        let args = Encode!(&arg0);
        self.caller.call(
            self.canister_id,
            super::CallMode::Update,
            "update_todo",
            args,
        )
    }
}

pub fn new(caller: &super::Caller, canister_id: Principal) -> BackendCanister {
    BackendCanister {
        canister_id,
        caller: caller.clone(),
    }
}

pub fn deploy(deployer: &super::Deployer) -> super::DeployBuilder<BackendCanister> {
    let args = Encode!();
    let result = deployer.deploy(args, new);
    let result = if let Some(id) = canister_id() {
        result.with_canister_id(id)
    } else {
        result
    };
    if let Some(wasm) = wasm() {
        result.with_wasm(wasm)
    } else {
        result
    }
}
pub fn canister_id() -> Option<Principal> {
    None
}

pub fn wasm() -> Option<Vec<u8>> {
    let mut path = std::path::PathBuf::new();
    path.push("../target/wasm32-wasip1/release/nowasi.wasm");
    let wasm =
        std::fs::read(path.as_path()).unwrap_or_else(|_| panic!("wasm binary not found: {path:?}"));
    Some(wasm)
}
